/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/Residencial_Areas.glb 
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { CameraModes, useCharacterCustomization } from '../../contexts/CustomizationContext'


export const tipologiasResidencias = ['2BR_G', '2BR', '3BR_G', '3BR', '4BR_T', '4BR']


const ResidencialAreas = (props) => {
  const { nodes, materials } = useGLTF('./models/Residencial_Areas.glb')
  const { tipologyResidencias, setTipologyResidencias, cameraMode, setCameraMode } = useCharacterCustomization()

  //State for hover scaling
  const [hoveredMesh, setHoveredMesh] = useState(null)

  //Refs for each mesh
  const meshRefs = useRef({})

  //Refs for materials to handle opacity
  const materialRefs = useRef({})

  //Effect to handle opacity and color changes
  useEffect(() => {
    Object.keys(materialRefs.current).forEach(meshName => {
      const material = materialRefs.current[meshName]
      if (material){
        if (hoveredMesh === meshName){
          material.opacity = 0.80
          material.emissive.set(0xffffff) // White emissive for bright white effect
          material.emissiveIntensity = 0.3
          material.needsUpdate = true
        } else {
          material.opacity = 0.35 // Restaurar la transparencia base de 0.75
          material.emissive.copy(material.originalEmissive) // Restore original emissive
          material.emissiveIntensity = 0
          material.needsUpdate = true
        }
        material.transparent = true
      }
    })
  }, [hoveredMesh])


  // Handle hover events
  const handlePointerOver = (meshName) => {
    setHoveredMesh(meshName)
  }

  const handlePointerOut = () => {
    setHoveredMesh(null)
  }

  // Mapping de objetos a imagenes y titulos
  const objectMappings = {
    '2BR_G': {image: './floorplans/Res_G.png', title: 'Two Bedrooms Garden: 140.00 M2'},
    '2BR': {image: './floorplans/Res_T.png', title: 'Two Bedrooms: 120.00 M2'},
    '3BR_G': {image: './floorplans/Res_G.png', title: 'Three Bedrooms Garden: 160.00 M2'},
    '3BR': {image: './floorplans/Res_T.png', title: 'Three Bedrooms: 140.00 M2'},
    '4BR_T': {image: './floorplans/R_4BR_R.png', title: 'Penthouse Roof: 200.00 M2'},
    '4BR': {image: './floorplans/R_4BR.png', title: 'Penthouse: 200.00 M2'}
  }


  // Handle click to active amenities camera
  const handleClick = (objectName) => {
    // setCameraMode(CameraModes.RESIDENCIAS)

    // Disparar evento para mostrar floating panel con informacion especifica del objeto
    const mapping = objectMappings[objectName]
    if (mapping) {
      window.dispatchEvent(new CustomEvent('annotation-click', {
        detail: {
          image: mapping.image,
          annotation: mapping.title,
          meshName: objectName
        }
      }))
    }
  }



  // Clone material to handle opacity and color changes
  const getMaterial = (baseMaterial, meshName) => {
    if (!materialRefs.current[meshName]){
      const clonedMaterial = baseMaterial.clone()
      clonedMaterial.transparent = true
      clonedMaterial.opacity = 0.75 // Establecer transparencia de 0.75
      clonedMaterial.originalColor = clonedMaterial.color.clone() // Store original color
      clonedMaterial.originalEmissive = clonedMaterial.emissive.clone() //Store original emissive
      materialRefs.current[meshName] = clonedMaterial
    }
    return materialRefs.current[meshName]
  }


  useEffect(() => {
    setTipologyResidencias(tipologiasResidencias)
  }, [tipologiasResidencias])

  const tipoCheck = (tipologia) => {
    return cameraMode === CameraModes.RESIDENCIAS && tipologyResidencias.includes(tipologia)
  }


  return (
    <group {...props} dispose={null}>
      <mesh
        ref={(el) => meshRefs.current['3BR_G'] = el}
        geometry={nodes.R_3BR_G.geometry} 
        material={getMaterial(materials.R_3BR_G, '3BR_G')}
        visible={tipoCheck('3BR_G')}
        scale={hoveredMesh === '3BR_G' ? 1.003 : 1}
        onPointerOver={() => handlePointerOver('3BR_G')}
        onPointerOut={handlePointerOut}
        onClick={() => handleClick('3BR_G')} 
      />

      <mesh
        ref={(el) => meshRefs.current['3BR'] = el}
        geometry={nodes.R_3BR.geometry} 
        material={getMaterial(materials.R_3BR, '3BR')}
        visible={tipoCheck('3BR')}
        scale={hoveredMesh === '3BR' ? 1.003 : 1}
        onPointerOver={() => handlePointerOver('3BR')}
        onPointerOut={handlePointerOut}
        onClick={() => handleClick('3BR')}    
      />

      <mesh
        ref={(el) => meshRefs.current['2BR_G'] = el}
        geometry={nodes.R_2BR_G.geometry} 
        material={getMaterial(materials.R_2BR_G, '2BR_G')}
        visible={tipoCheck('2BR_G')}
        scale={hoveredMesh === '2BR_G' ? 1.003 : 1}
        onPointerOver={() => handlePointerOver('2BR_G')}
        onPointerOut={handlePointerOut}
        onClick={() => handleClick('2BR_G')}  
      />
      
      <mesh
        ref={(el) => meshRefs.current['2BR'] = el}
        geometry={nodes.R_2BR.geometry} 
        material={getMaterial(materials.R_2BR, '2BR')} 
        visible={tipoCheck('2BR')}
        scale={hoveredMesh === '2BR' ? 1.003 : 1}
        onPointerOver={() => handlePointerOver('2BR')}
        onPointerOut={handlePointerOut}
        onClick={() => handleClick('2BR')} 
      />
      
      <mesh 
        ref={(el) => meshRefs.current['4BR_T'] = el}
        geometry={nodes.R_4BR_T.geometry} 
        material={getMaterial(materials.R_4BR, '4BR_T')}
        visible={tipoCheck('4BR_T')}
        scale={hoveredMesh === '4BR_T' ? 1.003 : 1}
        onPointerOver={() => handlePointerOver('4BR_T')}
        onPointerOut={handlePointerOut}
        onClick={() => handleClick('4BR_T')} 
      />

      <mesh
        ref={(el) => meshRefs.current['4BR'] = el}
        geometry={nodes.R_4BR.geometry} 
        material={getMaterial(materials.R_4BR, '4BR')}
        visible={tipoCheck('4BR')}
        scale={hoveredMesh === '4BR' ? 1.003 : 1}
        onPointerOver={() => handlePointerOver('4BR')}
        onPointerOut={handlePointerOut}
        onClick={() => handleClick('4BR')}  
      />

    </group>
  )
}

useGLTF.preload('./models/Residencial_Areas.glb')

export default ResidencialAreas
